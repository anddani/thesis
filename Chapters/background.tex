\textit{The process of developing, how Android installs the app and how it runs it is explained in this chapter. Additionally, some basic knowledge of the Discrete Fourier Transform is required when discussing differences in FFT implementations.}

\section{Android SDK}
To allow developers to build Android apps, Google developed a Standard Development Kit (SDK) to facilitate the process of writing Android applications. The Android SDK software stack is described in Figure~\ref{fig:sdk}. The Linux kernel is at the base of the stack, handling the core functionality of the device. Detecting hardware interaction, process scheduling and memory allocation are examples of services provided by the kernel. The Hardware Abstraction Layer (HAL) is an abstraction layer above the device drivers. This allows the developer to interact with hardware independent on the type of device\cite{android:hal}.

The native libraries are low level libraries, written in C or C++, that handle functionality such as the Secure Sockets Layer (SSL) and Open GL\cite{komatineni2012pro}. Android Runtime (ART) features Ahead-Of-Time (AOT) compilation and Just-In-Time (JIT) compilation, garbage collection and debugging support\cite{android:sdk:stack}. This is where the Java code is being run and because of the debugging and garbage collection support, it is also beneficial for the developer to write applications against this layer.

The Java API Framework is the Java library you use when controlling the Android UI. It is the reusable code for managing activities, implementing data structures and designing the application. The System Application layer represents the functionality that allows a third-party app to communicate with other apps. Example of usable applications are email, calendar and contacts\cite{android:sdk:stack}.

\begin{figure}
    \centering

    \begin{tikzpicture}[node distance=3pt,outer sep=0pt,
            blueb/.style={
                draw=white,
                fill=mybluei,
                rounded corners,
                text width=2.5cm,
                font={\sffamily\bfseries\color{white}},
                align=center,
                text height=12pt,
            text depth=9pt},
            greenb/.style={blueb,fill=mygreen},
            darkgreenb/.style={blueb,fill=mydarkgreen},
            redb/.style={blueb,fill=myred},
            greyb/.style={blueb,fill=mygrey},
            yellowb/.style={blueb,fill=myyellow},
        ]

        \node[label=center:{\sffamily\bfseries\color{white}System Applications},darkgreenb,minimum width=15.9cm] (SysApps) {};

        \node[label=center:{\sffamily\bfseries\color{white}Java API Framework},greenb,minimum width=15.9cm,below=of SysApps] (JAPI) {};

        \node[label=center:{\sffamily\bfseries\color{white}Native Libraries},greyb,below=of JAPI,minimum width=13cm,xshift=-1.45cm] (Nat) {};
        \node[label=center:{\sffamily\bfseries\color{white}ART},yellowb,right=of Nat] (Art) {};

        \widernode{Nat}{Art}{Hardware Abstraction Layer (HAL)}{Hal}

        \widernode[redb]{Hal}{Hal}{Linux Kernel}{RCP}
        \begin{pgfonlayer}{background}
            \draw[blueb,draw=black,fill=mybluei!40] 
                ([xshift=-\myframesep,yshift=3\myframesep]current bounding box.north west) 
                rectangle 
                ([xshift=\myframesep,yshift=-\myframesep]current bounding box.south east);
        \end{pgfonlayer}
        \node[font=\sffamily\itshape\color{black},above=of SysApps] {Android SDK Software Stack};
    \end{tikzpicture}
    \caption{Android SDK Software Stack\cite{android:sdk:stack}}
    \label{fig:sdk}
\end{figure}


\section{Dalvik Virtual Machine}
% Why is Dalvik Virtual Machine used?
Compiled Java code is executed on a virtual machine called the Java Virtual Machine (JVM). The reason for this is to allow compiled code to become portable. This way, every device, independent on architecture, with a JVM installed will be able to run the same code. The Android operating system is designed to be installed on many different devices\cite{android:os:devices}. Because of the many different devices, user applications would have to be compiled for all possible platforms it should work on. For this reason, Java byte code is a choice when wanting to distribute compiled applications.

The Dalvik Virtual Machine (DVM) is a virtual machine optimized for devices where resources are limited \cite{android:dalvik:internals}. The main focus of the DVM is to lower memory consumption and space of executables at the cost of \cite{security2009analysis}. 

% The DVM uses \cite{dalvik:vm:tech}

One difference between DVM and JVM is that the DVM uses a register-based architecture while the JVM uses a stack-based architecture. The most common virtual machine architecture is the stack-based \cite[p.~158]{craig2010virtual}. A stack-based architecture evaluates each expression directly on the stack and always have the last evaluated value on top of the stack. Thus, only a stack pointer is needed to find the next instruction on the stack.

Contrary to this, a register based virtual machine works more like a CPU. It uses a set of registers where it will place operands by fetching them from memory. One advantage of using register-based architecture is that fetching data between registers is faster than fetching or storing data onto the hardware stack. The biggest disadvantage of using register-based architecture is that the compilers must be more complex than for stack-based architecture. This is because the code generators must take register management into consideration \cite[p.~159-160]{craig2010virtual}.
% http://davidehringer.com/software/android/The_Dalvik_Virtual_Machine.pdf

% Why was it used?

\subsection{Dalvik Executables}

% What are dex files?

% How do they compare to class files

\section{Android Runtime}

% What is Android Runtime?

% Why is it used instead of Dalvik?

\subsection{Installation Process}
% How is it used

% PROS: information gathered from runtime, inlining

Applications for the Android operating system are mostly written in Java for easier portability between \cite[p.~33]{nolan2012decompiling}

\section{Native Development Kit}

\subsection{Java Native Interface}

\subsection{Clang and LLVM}

\section{Discrete Fourier Transform}

\begin{figure}[h]
    \renewcommand\thesubfigure{(\alph{subfigure})}
    \centering
    \begin{tikzpicture}
        \begin{groupplot}[group style={group name=my plots,group size= 2 by 1,horizontal sep =1.5cm,vertical sep =2cm},width=6cm]
            \nextgroupplot[legend pos=north east,
                trig format plots=rad,
                axis lines = middle,
                enlargelimits,
                width=8cm,
                height=5cm,
                ymin=-0.5,
                ymax=0.5,
                xlabel={},
                clip=false
            ]
            \addplot[domain=-0.5*pi:2*pi,samples=200,red] {0.5*sin(x + pi*1/4)};
            \nextgroupplot[legend pos=north east,
                    trig format plots=rad,
                    axis lines = middle,
                    enlargelimits,
                    ymin=-0.5,
                    ymax=0.5,
                    width=8cm,
                    height=5cm,
                    xlabel={},
                    clip=false
            ]
            \addlegendimage{empty legend}
            \addplot[domain=-0.5*pi:2*pi,samples=200,red] {0.3*sin(4*x)};
        \end{groupplot}
        \begin{scope}[yshift=-6cm]
            \begin{axis}[
                    trig format plots=rad,
                    axis lines = middle,
                    enlargelimits,
                    ymin=-0.5,
                    ymax=0.5,
                    width=16cm,
                    height=5cm,
                    x label style={at={(axis description cs:0.5,-0.6)},anchor=north},
                    xlabel={c) $f(x) = 0.5\sin(x + 0.5\pi) + 0.3\sin(4x)$},
                    clip=false
                ]
                \addplot[domain=-0.5*pi:2.6*pi,samples=200,blue] {0.5*sin(x + pi*1/2) + 0.3*sin(4*x)};
                \draw[dotted,black] (axis cs: 0.5*pi,-1.1) -- (axis cs: 0.5*pi,0);
                \draw[dotted,black] (axis cs: 2.5*pi,-1.1) -- (axis cs: 2.5*pi,0);
                \draw[dashed,black,<->] (axis cs: 0.5*pi,-1.05) -- node[below,text=black,font=\footnotesize]{cycle}(axis cs: 2.5*pi,-1.05);
            \end{axis}
        \end{scope}
        \node[text width=6cm,align=center,anchor=north] at ([yshift=-5mm]my plots c1r1.south) (cap1) {a) $f(x) = 0.5\sin(x + 0.5\pi)$};
        \node[text width=6cm,align=center,anchor=north] at ([yshift=-5mm]my plots c2r1.south) (cap2) {b) $f(x) = 0.3\sin(4x)$};
    \end{tikzpicture}
    \caption{Sum of sinusoids}\label{fig:dft:ex1}
\end{figure}
