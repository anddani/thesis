\textit{To ensure that the experiment is carried out correctly, many different tools for measurements was evaluated. Different implementations of the FFT are also compared to choose the ones that would typically be used in an Android project.}
% Test how large the cost of JNI
% Debug/VMDebug libraries

% Preparation
% What tools are used? Phone, software, libraries (currenttimemillis vs nantotime etc),
% Different thread pools
% Measure execution time
% Measure memory consumption
% Benchmark Environment (Which phone, Android version, Compiler version, Java version, compiler flags)
% Benchmark Environment parameters (Started apps, memory left, started processes? cpu throttling by mobile case?)
% Profilers for time and memory measurement
% Disable Instant Run??
% Which operations should be included?
% Should I Measure every operation in detail?
% Garbage collection discussion (You cannot control it)
\section{Experiment model}

% http://lessthanoptimal.github.io/Java-Matrix-Benchmark/manual/MethodologyRuntimeBenchmark/
% In java, we cannot control GC, which can lead to varying results
% In java, do not use string concatenation (will ask for memory)
% Measure first, optimize later
This experiment consisted of tests for three different aspects of implementing algorithms in Java and in native code. To get an overview of how much of an impact different parts of an implementation have, the following subjects were investigated:

\begin{enumerate}
    \item Cost of using the JNI
    \item Compare well known libraries
    \item Compare two optimized code samples in Java and C++
\end{enumerate}

The reason why it is relevant to know how significant the JNI is, is because we want to see for what size of the data the transition time for going between Java and native is irrelevant compared to the total execution time of the JNI call. This would also show how much repeated calls to native code would affect the performance of a program. By minimizing the number of calls to the JNI, a program would get potentially faster.

There are many different implementations of the FFT publicly available that might be of interest for use in ones project. This test demonstrates how some different libraries compare. It is helpful to see how viable different implementations are on Android, for both C++ libraries and Java libraries. It can also be useful to know how a small implementation compares to a large and complex library.

Finally, comparing optimization techniques for small libraries is a good way of demonstrating how a developer can improve performance to fit the requirements while still retaining manageable source code. Having one single source file is valuable, especially for native libraries.

\subsection{Hardware}
% Phone model
% Screen Brightness
% Battery percentage?
The Google Nexus 6P was used throughout all experiments to get comparable results.

\subsection{Benchmark Environment}
% Android version
% Cellular on?
% Wifi on?
% Which apps were in background?

\subsection{Time measurement}
% SystemClock.elapsedRealtime
% SystemClock.elapsedRealtimeNanos
% SystemClock.uptimeMillis
% System.currentTimeMillis

\subsection{Memory measurement}

% How will the results be represented?
% How will I interpret the results
% How many times will the programs be executed
% Statistical significance
% What is included in the calculation, what is not (adding result to string etc)
\section{Evaluation}

\subsection{Data representation}
\subsection{Data interpretation}
\subsection{Statistical significance}

% Description of which algorithms that are available, which one that is used and why
% Detailed description/comparison between the code.
% Correctness test/verification??
% Complexity
% Test data: sizes of data, datatypes (long vs int vs float vs double)

\section{JNI Tests}

% Small block size
% Large block size
\section{Fast Fourier Transform Algorithms}

\subsection{Java libraries}
JTransforms\cite{jtransforms:benchmark}

\subsection{C++ libraries}
% Flags: -funroll-loops
\cite{FFTW05}

