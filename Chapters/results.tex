\textit{Results from the JNI tests, FFT libraries and NEON optimizations are presented here.}

%%==================================================================
%% JNI-Tests
%%==================================================================
\section{JNI}
The results of the tests that measure the JNI overhead can be found in Table~\ref{tab:jni:common}. These tests are presented with block sizes defined in chapter \ref{ch:method} - Method. Execution time and confidence intervals are given in microseconds and are rounded to four decimal points. The number after the $\pm$ sign is a two sided confidence interval with a confidence level of $95\%$. Each test was executed 100 times to ensure that we get more reliable sample means.

The test labeled \textbf{No params} is the test where a native void function with no parameters that returns immediately was called. \textbf{Vector} takes a \texttt{jdoubleArray} and returns a \texttt{jdoubleArray} immediately. \textbf{Convert} takes a \texttt{jdoubleArray}, converts it to a native array using \texttt{GetPrimitiveArrayCritical()}, converts it back to a \texttt{jdoubleArray} using \texttt{ReleasePrimitiveArrayCritical()} and returns a \texttt{jdoubleArray}. \textbf{Columbia} takes three \texttt{jdoubleArray}s, converts them with \texttt{GetPrimitiveArrayCritical()}, releases them with \texttt{ReleasePrimitiveArrayCritical()} and returns one \texttt{jdoubleArray}.

% DISCUSS HERE WHEN CORRECT DATA IS GATHERED
% As seen in Table \ref{tab:jni:common}, the execution times for calling the JNI varied in the range of one microseconds and 14 microseconds. \textbf{Columbia} with block size \textbf{6}

\begin{table}[H]
    \centering
    \caption{Results from the JNI tests, Time (\textmu s)}
    \label{tab:jni:common}
    \input{Data/results/JNI/common_table_JNI.tex}
\end{table}



%%==================================================================
%% FFT-Tests
%%==================================================================
\section{FFT Libraries}
The results from the FFT Libraries are presented in line graphs, both language specific and graphs with both Java and C++ are given to illustrate the differences between languages and also provide differences for specific languages clearly. The time unit for these tests are presented in milliseconds as opposed to microseconds that the JNI was measured in. This was because the FFT ran in ranges below one millisecond and above one second among different algorithms and different block sizes. The means are calculated from the results of 100 test runs.

\subsection{Small block sizes}
Results from the small blocks tests shows clear difference between the different algorithms. In Figure~\ref{fig:all:line:small}, Princeton Recursive in Java perform the worst. Princeton Recursive in C++ and Princeton Iterative in Java perform better than Princeton Recursive Java although worse than the rest of the algorithms. % CHECK IF STILL RELEVANT AFTER NEW TESTS

% In Table ... we can see that the difference is statistically significant.

% found in Table~\ref{tab:cpp:small} and Table~\ref{tab:java:small}, shows that 


\begin{figure}
    \centering
    \input{Data/results/FFT/line_graph_SMALL.tex}
    \caption{Line graph for all algorithms, small block sizes}
    \label{fig:all:line:small}
\end{figure}

\begin{figure}
    \centering
    \input{Data/results/FFT/CPP_line_graph_SMALL.tex}
    \caption{C++ line graph for small block sizes}
    \label{fig:cpp:line:small}
\end{figure}
\begin{table}
    \centering
    \caption{C++ results table for small block sizes}
    \label{tab:cpp:small}
    \resizebox{\columnwidth}{!}{
        \input{Data/results/FFT/CPP_common_table_SMALL.tex}
    }
\end{table}


\begin{figure}
    \centering
    \input{Data/results/FFT/Java_line_graph_SMALL.tex}
    \caption{Java line graph for small block sizes}
    \label{fig:java:line:small}
\end{figure}
\begin{table}
    \centering
    \caption{Java results table for small block sizes}
    \label{tab:java:small}
    \resizebox{\columnwidth}{!}{
        \input{Data/results/FFT/Java_common_table_SMALL.tex}
    }
\end{table}

\subsection{Medium block sizes}
\begin{figure}
    \centering
    \input{Data/results/FFT/line_graph_MEDIUM.tex}
    \caption{Line graph for all algorithms, medium block sizes}
    \label{fig:all:line:medium}
\end{figure}

\begin{figure}
    \centering
    \input{Data/results/FFT/CPP_line_graph_MEDIUM.tex}
    \caption{C++ line graph for medium block sizes}
    \label{fig:cpp:line:medium}
\end{figure}
\begin{table}
    \centering
    \caption{C++ results table for small block sizes}
    \label{tab:cpp:medium}
    \resizebox{\columnwidth}{!}{
        \input{Data/results/FFT/CPP_common_table_MEDIUM.tex}
    }
\end{table}


\begin{figure}
    \centering
    \input{Data/results/FFT/Java_line_graph_MEDIUM.tex}
    \caption{Java line graph for medium block sizes}
    \label{fig:java:line:medium}
\end{figure}
\begin{table}
    \centering
    \caption{Java results table for medium block sizes}
    \label{tab:java:medium}
    \input{Data/results/FFT/Java_common_table_MEDIUM.tex}
\end{table}

\subsection{Large block sizes}

\begin{figure}
    \centering
    \input{Data/results/FFT/line_graph_LARGE.tex}
    \caption{Line graph for all algorithms, large block sizes}
    \label{fig:all:line:large}
\end{figure}

\begin{figure}
    \centering
    \input{Data/results/FFT/CPP_line_graph_LARGE.tex}
    \caption{C++ line graph for large block sizes}
    \label{fig:cpp:line:large}
\end{figure}
\begin{table}
    \centering
    \caption{C++ results table for large block sizes}
    \label{tab:cpp:large}
    \resizebox{\columnwidth}{!}{
        \input{Data/results/FFT/CPP_common_table_LARGE.tex}
    }
\end{table}


\begin{figure}
    \centering
    \input{Data/results/FFT/Java_line_graph_LARGE.tex}
    \caption{Java line graph for large block sizes}
    \label{fig:java:line:large}
\end{figure}
\begin{table}
    \centering
    \caption{Java results table for large block sizes}
    \label{tab:java:large}
    \input{Data/results/FFT/Java_common_table_LARGE.tex}
\end{table}


% Which is slowest and why (discussion)??

% Which is fastest and why (discussion)??

% Which tests triggered the GC??

%%==================================================================
%% NEON-Tests
%%==================================================================
\section{Optimizations}

\begin{table}
    \centering
    \caption{Java results table for extra large block sizes}
    \label{tab:java:extra}
    \input{Data/results/FFT/Java_common_table_EXTRA.tex}
\end{table}

\begin{figure}
    \centering
    \input{Data/results/NEON/line_graph_EXTRA.tex}
    \caption{NEON results table for extra large block sizes}
    \label{fig:neon:line:extra}
\end{figure}

\begin{table}
    \centering
    \input{Data/results/NEON/CPP_common_table_EXTRA.tex}
    \caption{C++ results table for extra large block sizes}
    \label{tab:cpp:extra}
\end{table}

\begin{table}
    \centering
    \resizebox{\columnwidth}{!}{
        \input{Data/results/FFT/CPP_common_table_EXTRA.tex}
    }
    \caption{C++ results table for extra large block sizes}
    \label{tab:cpp:extra}
\end{table}

\begin{figure}
    \centering
    \input{Data/results/FFT/line_graph_EXTRA.tex}
    \caption{Line graph for all algorithms, extra large block sizes}
    \label{fig:all:line:extra}
\end{figure}

